package net.cgps.wgsa.paarsnp.builder;

import net.cgps.wgsa.paarsnp.core.lib.ElementEffect;
import net.cgps.wgsa.paarsnp.core.lib.SequenceType;
import net.cgps.wgsa.paarsnp.core.lib.SetResistanceType;
import net.cgps.wgsa.paarsnp.core.lib.json.ResistanceSet;
import net.cgps.wgsa.paarsnp.core.snpar.MutationType;
import net.cgps.wgsa.paarsnp.core.snpar.SnparReferenceSequence;
import net.cgps.wgsa.paarsnp.core.snpar.json.ResistanceMutation;
import net.cgps.wgsa.paarsnp.core.snpar.json.SnparLibrary;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.util.*;
import java.util.function.BiFunction;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class SnparReader implements BiFunction<Path, Path, SnparLibrary> {
  private final static Pattern snpIdPattern = Pattern.compile("^([\\-A-Z]+)([0-9]+)([A-Z\\-]+)$");

  private static final String HEADER_START = "type";
  private static final String SAP_KEY = "SAP";
  private static final String SNP_KEY = "SNP";

  private final Logger logger = LoggerFactory.getLogger(SnparReader.class);

  private final String speciesId;

  public SnparReader(String speciesId) {
    this.speciesId = speciesId;
  }

  private static MutationType determineMutationType(final String key) {

    final MutationType mutationType;

    if (SNP_KEY.equals(key) || SAP_KEY.equals(key)) {
      mutationType = MutationType.S;
    } else {
      mutationType = MutationType.valueOf(key);
    }

    return mutationType;
  }

  @Override
  public SnparLibrary apply(final Path snparCsvFile, final Path snparFastaFile) {

    final Map<String, SnparReferenceSequence> referenceSequences = new OneLineFastaReader()
        .apply(snparFastaFile)
        .entrySet()
        .stream()
        .collect(Collectors.toMap(Map.Entry::getKey, idToDna -> new SnparReferenceSequence(idToDna.getKey(), 80.0f, 80.0f, idToDna.getValue())));

    final Map<String, ResistanceSet> resistanceSets = new HashMap<>(50);

    try (final CSVParser parser = CSVParser.parse(snparCsvFile.toFile(), Charset.defaultCharset(), CSVFormat.RFC4180.withFirstRecordAsHeader())) {

      for (final CSVRecord csvRecord : parser.getRecords()) {

        final String geneName = csvRecord.get("Gene Name").trim();
        this.logger.trace("geneName={}", csvRecord.get(0));

        // Check there's a rep available.
        if (!referenceSequences.containsKey(geneName)) {
          throw new RuntimeException("Terminal error, not found sequence: " + geneName);
        }

        final Set<String> antimicrobialAgents = new HashSet<>(Arrays.asList(csvRecord.get("Resistance Profile").split(",")));

        final String mutation = csvRecord.get("Mutation").trim();

        final String uniqueMutationName = geneName + "_" + mutation;

        // The resistance group is named after the unique ID of the mutation if no set name is provided (ie there's only one member of the set so name is autogenerated).
        final String resistanceSetName = csvRecord.get("Resistance Group").isEmpty() ? uniqueMutationName : csvRecord.get("Resistance Group").trim();

        // Create the resistance set if new, otherwise add to it.
        final SetResistanceType setEffect = SetResistanceType.valueOf(csvRecord.get("Set Effect").trim().toUpperCase());

        if (!resistanceSets.containsKey(resistanceSetName)) {

          this.logger.debug("Using {} to initialise set {}", mutation, resistanceSetName);

          resistanceSets.put(resistanceSetName, ResistanceSet.buildSnpResistanceSet(resistanceSetName, geneName, mutation, antimicrobialAgents, setEffect, ElementEffect.valueOf(csvRecord.get("Effect"))));

        } else {

          this.logger.debug("Adding {} to set {}", mutation, resistanceSetName);

          resistanceSets.get(resistanceSetName).addElement(geneName, mutation, ElementEffect.RESISTANCE);
          this.logger.debug("Set now contains {}", String.join(",", resistanceSets.get(resistanceSetName).getElementIds()));
        }

        final MutationType mutationType = MutationType.S;

        final Matcher matcher = snpIdPattern.matcher(mutation);

        if (!matcher.find()) {
          throw new RuntimeException("Unable to match SAP data: " + mutation);
        }

        final String originalSequence = matcher.group(1);
        final String mutantSequence = matcher.group(3);

        final int rawPosition = StringUtils.isNumeric(mutation) ? Integer.valueOf(mutation) : Integer.valueOf(matcher.group(2));

        final VariantType variantType = VariantType.valueOf(csvRecord.get("Mutation Type"));
        final Integer position = VariantType.SAP == variantType ? (rawPosition * 3) - 2 : rawPosition;
        final SequenceType sequenceType = VariantType.SAP == variantType ? SequenceType.PROTEIN : SequenceType.DNA;

        referenceSequences.get(geneName).addMutation(new ResistanceMutation(uniqueMutationName, resistanceSetName, sequenceType, geneName, originalSequence, position, mutantSequence, ""));
      }
    } catch (final IOException e) {
      this.logger.error("Failed to read SNPAR CSV file {}", snparCsvFile.toAbsolutePath().toString());
      throw new RuntimeException(e);
    }

    final double minPid = referenceSequences
        .values()
        .stream()
        .mapToDouble(SnparReferenceSequence::getSeqIdThreshold)
        .min().orElse(90.0)
        - 5.0;

    return new SnparLibrary(referenceSequences, resistanceSets, this.speciesId, minPid);
  }
}
